#!/usr/bin/env bash

source ./bin/init-env

if [ $# -eq 0 ]
  then
    echo "Setting up dev db"
    echo "You can start either production or development"
    echo "e.g bin/db-setup dev"
    echo "e.g bin/db-setup prod"
fi

PF_TARGET="${1:-dev}"

POSSIBLE_VALUES=("prod" "dev")

if [[ ! " ${POSSIBLE_VALUES[@]} " =~ " ${PF_TARGET} " ]]; then
  echo "target should be either: prod or dev"
  exit 1
fi

./bin/services-start "$@" && \
  ./bin/server-start "${PF_TARGET}"

case "${PF_TARGET}" in
  'prod')
    SERVICE_ENV='prod'
  ;;
  'dev')
    SERVICE_ENV='dev'
  ;;
esac

docker exec -it ${SERVICE_NAME}-${SERVICE_ENV}-app bash -c 'bin/rails db:create db:migrate db:seed'


./bin/services-start "$@"

docker container ls | grep ${SERVICE_NAME}-${SERVICE_ENV}-app 1> /dev/null
if [[ $? = 1 ]]; then
  echo "Starting [${PF_TARGET}] Server..."
else
  echo "Server [${PF_TARGET}] Started!"
fi

case "${PF_TARGET}" in
  'prod')
    FULL_SERVICE_ENV='production'
    SERVICE_ENV='prod'
    SERVER_PUBLISHED_PORT=${PROD_SERVER_PUBLISHED_PORT}
  ;;
  'dev')
    FULL_SERVICE_ENV='development'
    SERVICE_ENV='dev'
    SERVER_PUBLISHED_PORT=${DEV_SERVER_PUBLISHED_PORT}

    docker run --rm --detach \
    --name ${SERVICE_NAME}-${SERVICE_ENV}-app \
    --env RAILS_LOG_TO_STDOUT=true \
    --env LOG_LEVEL=debug \
    --network ${SERVICE_NAME}-bridge-docker-network \
    --publish ${SERVER_PUBLISHED_PORT}:3000 \
    --env REDIS_URL=redis://${SERVICE_NAME}-redis:6379/1 \
    --env DATABASE_URL=mysql2://${DB_USER}:${DB_PASSWORD}@${SERVICE_NAME}-db:3306/${SERVICE_NAME}_${FULL_SERVICE_ENV} \
    --mount type=bind,source=$PWD,target=${ARG_APP_PATH} \
    ${SERVICE_NAME}/${SERVICE_ENV}:latest bash -c 'bin/rails server -p 3000 --early-hints -b 0.0.0.0'
  ;;
esac


docker exec -it ${SERVICE_NAME}-${SERVICE_ENV}-app bash -c 'bin/rails console'

docker container ls | grep ${SERVICE_NAME}-db 1> /dev/null
if [[ $? = 1 ]]; then
  echo "DB Stop!"
  docker container rm ${SERVICE_NAME}-db > /dev/null 2>&1
else
  echo "Stopping DB..."
  docker container stop ${SERVICE_NAME}-db 1> /dev/null
fi

export DB_PASSWORD=mysql_password && mysql -u root -p${DB_PASSWORD}

CREATE USER 'mysql_user'@'%' IDENTIFIED BY 'mysql_user';
GRANT ALL PRIVILEGES ON *.* TO 'mysql_user'@'%';
GRANT ALL PRIVILEGES ON *.* TO 'mysql_user'@'%' IDENTIFIED BY 'mysql_user';

CREATE DATABASE pam_development;



GRANT ALL PRIVILEGES ON *.* TO 'mysql_user'@'%' IDENTIFIED BY 'mysql_user';
CREATE DATABASE iwl_development;

set SERVICE_NAME iwl \
docker exec -it $SERVICE_NAME-db \
  --env DB_USER=mysql_user \
  --env DB_PASSWORD=mysql_password \
  bash -c "mysql -u $DB_USER -p$DB_PASSWORD -e 'SHOW DATABASES;'"

set SERVICE_NAME iwl \
set DB_USER mysql_user \
set DB_PASSWORD mysql_password \
docker exec -it $SERVICE_NAME-db \
  bash -c "mysql -u $DB_USER -p$DB_PASSWORD -e 'SHOW DATABASES;'" > $stdout


export DB_USER=mysql_user && \
export DB_PASSWORD=mysql_password && \
mysql -u ${DB_USER} -p${DB_PASSWORD} -e 'SHOW DATABASES;'

psql -U postgres -c 'DROP DATABASE IF EXISTS pam_test;'"

SHOW DATABASES;


Access denied for user 'mysql_user'@'%' to database 'iwl_development'

mysql -u mysql -p
mysql -u root -psupersecret

CREATE USER 'mysql'@'%' IDENTIFIED BY 'mysql';

GRANT ALL PRIVILEGES ON *.* TO 'mysql'@'%' IDENTIFIED BY 'mysql';

CREATE DATABASE pam_development;

docker exec isms-db-pg bash -c "psql -U pam_user pam_test -c <<< echo '\l'"

docker exec isms-db-pg bash -c "psql -U postgres -c 'DROP DATABASE IF EXISTS pam_test;'"
docker exec isms-db-pg bash -c "psql -U postgres -c 'CREATE DATABASE pam_test;'"

